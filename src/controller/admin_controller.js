const Malware = require('../model/malwaresubmit_model');
const MalwareCSV = require('../model/malware_csv');
const Asn = require('../model/asn_model');
const csv = require('fast-csv');
const mongoose = require('mongoose');
const DomainLookup = require('../model/domain_lookup');
const getDomainInfoByAPI = require('../helper').getDomainInfoByAPI;
const getDomainInfoByDB = require('../helper').getDomainInfoByDB;
const checkExistDomain = require('../helper').checkExistDomain;
const checkStatusUrl = require('../helper').urlStatusCheck;
const getHostName = require('../helper').getHostName;
const addNewDomain = require('../controller/asn_controller').addNewDomain;
const addNewMalware = require('../controller/asn_controller').addNewMalware;
const AdminUser = require('../model/admin_user');
const fs = require('fs');
const path = require('path');

const cron = require('node-cron');
const constants = require('../constants');

exports.checkAdminUser = (req, res) => {
    var userName = req.body.username;
    var userPass = req.body.password;

    let rawdata = fs.readFileSync(path.join(__dirname, '../../superAdmin.json'));
    let superAdmin = JSON.parse(rawdata);

    if (userName == superAdmin.superUserName && userPass == superAdmin.superUserPassword) {
        req.session.adminType = constants.admin_types.SUPER;
        // req.session.user = {
        //     userName: "Super Admin",
        //     userEmail: 'support@threathaus.com'
        // };
        res.status(200).json({ userTrust: 1 })
    } else {
        AdminUser.findOne({ userName: userName }, (err, user) => {
            if (err) {
                res.send(err);
            } else {
                if (user && user.userPassword == userPass) {
                    req.session.adminType = constants.admin_types.MODERATE;
                    // delete user.userPassword;
                    // req.session.user = user;
                    res.status(200).json({ userTrust: 0 });
                } else {
                    res.status(401).json({ msg: 'wrong password' });
                }
            }
        });
    }
}

exports.addNewMorderateAdmin = (req, res) => {
    console.log(req.body);
    var adminUser = new AdminUser({
        userName: req.body.userName,
        userEmail: req.body.userEmail,
        userPassword: req.body.userPassword
    });
    adminUser.save()
        .then((data) => {
            console.log("response admin", data);
            res.status(200).json(data);
        })
        .catch((err) => {
            res.send(err);
        });
}

exports.updateAdmin = (req, res) => {
    console.log("updateAdmin");
    AdminUser.findOneAndUpdate({ _id: req.body._id }, req.body, (err, user) => {
        if (err) return res.status(500).send(err);
        return res.json(user);
    })
}

exports.getAllModerateUser = (req, res) => {
    console.log("get Admin users");
    AdminUser.find({}, (err, data) => {
        if (err) console.log(err);
        res.status(200).json(data);
    })
}

exports.deleteAdmin = (req, res) => {
    console.log("deleteAdmin");
    var deletedId = req.params.id;
    AdminUser.remove({
        _id: deletedId
    }, (err) => {
        if (err)
            res.send(err);
        res.status(200).json({ delete_id: deletedId });
    });
}

exports.getAllMalware = async (req, res) => {
    console.log('get all malware here');
    var malwares = await Malware.find({}).sort({ dataAdded: -1 }).exec();
    var csv_malwares = await getAllCSVMalwares();
    var totolMalwares = [...malwares, ...csv_malwares];
    res.json(totolMalwares);
}

exports.getMalware = (req, res) => {
    let id = { _id: req.params.id };
    Malware.findOne(id, (err, asns) => {
        if (err) {
            res.send(err);
        } else {
            res.json(asns);
        }
    });
}

exports.deleteMalware = (req, res) => {
    console.log('malware delete');
    Malware.remove({
        url: req.params.url
    }, (err, malware) => {
        if (err)
            res.send(err);
        res.json({ message: 'Malware successfully deleted!' });
    });
}

exports.deleteSubmitMalware = (req, res) => {
    var delete_id = req.params.id;
    console.log(delete_id);
    Malware.find({ _id: delete_id }, async (err, malware) => {
        if (err) {
            throw err;
        } else {
            console.log("delete malware: ", malware);
            var url = malware[0].url_ip;
            await Asn.remove({ url_ip: url });
            console.log("delete url", url);

            Malware.remove({
                _id: req.params.id
            }, (err) => {
                if (err)
                    res.send(err);
                res.status(200).json({ delete_id: delete_id });
            });
        }

    })
}

exports.updateMalware = (req, res) => {

    Malware.findOneAndUpdate(
        { _id: req.body.id },
        req.body,
        (err, data) => {
            if (err) throw err;
            res.send("success");
        })
}

exports.importCSV = async (req, res) => {
    if (!req.files)
        return res.status(400).send('No files were uploaded.');
    var csvFile = req.files.file;
    var allDatas = [];
    var csvDatas = [];
    var unRegistedDomainCount = 0;
    csv
        .fromString(csvFile.data.toString(), {
            headers: true,
            ignoreEmpty: true
        })
        .on("data", function (data) {
            allDatas.push(data);
        })
        .on("end", async function () {
            for (var data of allDatas) {
                const mal = await Malware.find({ url_ip: data['url_ip'], tag: data['tag'] }).exec();
                if (mal.length == 0) {
                    data['_id'] = new mongoose.Types.ObjectId();
                    data['approval'] = true;
                    csvDatas.push(data);
                }
            }
            Malware.insertMany(csvDatas, function (err, documents) {
                if (err) {
                    throw err;
                } else {
                    res.json(documents);
                }
            });
            for (var i = 0; i < csvDatas.length; i++) {
                var checkDomain = getHostName(csvDatas[i].url_ip);
                DomainLookup.find({ domain: checkDomain }, (err, data) => {
                    if (err) throw err;
                    if (data.length > 0) unRegistedDomainCount++;
                });
                await submitCSV(csvDatas[i]);
            }
        });
}

const getAllCSVMalwares = () => {
    return new Promise((resolve, reject) => {
        MalwareCSV.find({}, (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

const submitCSV = async (csv) => {
    try {
        var result = {};
        var domain = getHostName(csv.url_ip);
        var urlStatus = await checkStatusUrl(csv.url_ip);
        var checkDomain = await checkExistDomain(domain);
        if (!checkDomain) {
            console.log("new domian add feature: /n");
            var domainInfo = await getDomainInfoByAPI(domain);
            await addNewDomain(domainInfo);
            result = { ...csv, ...domainInfo };
            result.status = urlStatus == "online" ? "online" : "offline";
            result.virusTotal = constants.virusTotalUrl + csv.url_ip
            result.reporter = csv.reporter == "" ? "Anonymous" : csv.reporter;
        } else {
            console.log("already exist domain :");
            var domainInfodb = await getDomainInfoByDB(domain);
            result = { ...csv };
            result.status = urlStatus == "online" ? "online" : "offline";
            result.reporter = csv.reporter == "" ? "Anonymous" : csv.reporter;
            result.ip = domainInfodb.ip;
            result.ASN = domainInfodb.ASN;
            result.country = domainInfodb.country;
            result.virusTotal = constants.virusTotalUrl + csv.url_ip
            result.domain_registrar = domainInfodb.domain_registrar;
            result.domain_ip_owner = domainInfodb.domain_ip_owner;
        }

        var asn = new Asn(result);
        asn.save()
            .then((asn) => {
                console.log("csv data have been successfully added")
            })
            .catch((err) => {
                console.log(err)
            });
    } catch (error) {
        console.log(error);
    }
}


// CRONJOB every 4 hours
cron.schedule('*/30 * * * *', () => {
    
    importCSVFile();
});

const importCSVFile = async () => {
    var allDatas = [];
    var csvDatas = [];
    var filepath = path.join(__dirname, '../public/phishingurls_csv/phishingurls.csv');
    fs.createReadStream(filepath)
    .pipe(csv.parse({ 
        headers: true,
        ignoreEmpty: true
    })
    .on("data", function (data) {
        allDatas.push(data);
    })
    .on("end", async function () {
        for (var data of allDatas) {
            const mal = await Malware.find({ url_ip: data['url_ip'], tag: data['tag'] }).exec();
            if (mal.length == 0) {
                data['_id'] = new mongoose.Types.ObjectId();
                data['approval'] = true;
                csvDatas.push(data);
            }
        }

        // var fs = require('fs');

        // const csvpath = '../public/phishingurls_csv/phishingurls.csv';

        // fs.unlinkSync(filepath);

        Malware.insertMany(csvDatas, function (err, documents) {
            if (err) {
                throw err;
            } else {
                // res.json(documents);

                documents.forEach(async body => {
                    await addNewMalware({ body }, false);

                    

                });
                ;
            }
        });
    }));

    
}
