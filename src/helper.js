const axios = require('axios');
const request = require('request');
const dns = require('dns');
const asn = require('./model/asn_model');
const DomainLookup = require('./model/domain_lookup');
const Malware = require('./model/malwaresubmit_model');

const getWhoisInfo = (domain) => {
    return new Promise((resolve, reject) => {
        request.get({
            url: 'https://api.webcargo.io/whois',
            qs: { 'key': 'LyH47uEcVXvLI9jgQwrTif5qr2a89vSi', 'identifier': domain }
        }, (error, response, body) => {
            if (error) {
                reject(error);
            } else if (response.statusCode == 200) {
                resolve(body);
            } else {
                reject(body);
            }
        });
    });
}

const ipLookupPromise = (domain) => {
    return new Promise((resolve, reject) => {
        dns.lookup(domain, (err, address, family) => {
            if (err) reject(err);
            resolve(address);
        });
    });
}

const getApprovalInfo = (id) => {
    return new Promise((resolve, reject) => {
        Malware.findOne({ _id: id }, (err, datas) => {
            if (err) throw reject(err);
            resolve(datas);
        });
    });
}

const findDomain = (domain) => {
    return new Promise((resolve, reject) => {
        DomainLookup.find({ domain: domain }, (err, res) => {
            if (err) throw reject(err);
            if (res.length > 0) {
                resolve(true);
            } else {
                resolve(false);
            }
        });
    });
}

exports.urlStatusCheck = (url) => {

    return new Promise((resolve, reject) => {
        request({ method: 'HEAD', uri: url }, function (error, response, body) {
            if (!error && response.statusCode >= 200 && response.statusCode < 400) {
                resolve('online');
            } else {
                resolve('offline');
            }
        })
    })
}

exports.getDomainInfoByAPI = async (domain) => {
    try {
        var ip = await ipLookupPromise(domain);

        var getWhoisInfo = await axios.get('https://api.webcargo.io/whois', {
            params: { key: "LyH47uEcVXvLI9jgQwrTif5qr2a89vSi", identifier: domain }
        });
        var getAsnInfo = await axios.get('https://api.iptoasn.com/v1/as/ip/' + ip);
        var getGeoInfo = await axios.get('https://api.webcargo.io/ip', {
            params: { key: "LyH47uEcVXvLI9jgQwrTif5qr2a89vSi", ip_address: ip }
        });

        var malwareInfo = getWhoisInfo.data.result;

        var result = {};
        result.domain = domain;
        result.ip = ip;
        result.ASN = getAsnInfo.data.as_number;
        getGeoInfo ? result.country = getGeoInfo.data.country_code : "";

        if (malwareInfo) {
            result.domain_registrar = malwareInfo.registrar ? malwareInfo.registrar.name : "";
            result.domain_ip_owner = malwareInfo.contacts.length == 0 ? "" : malwareInfo.contacts.owner[0].organization;
        } else {
            result.domain_registrar = "";
            result.domain_ip_owner = "";
        }
        return result;
    } catch (err) {
        console.log('error message', err);
    }

}

exports.getDomainInfoByDB = (domain) => {
    return new Promise((resolve, reject) => {
        DomainLookup.findOne({ domain: domain }, (err, datas) => {
            if (err) throw reject(err);
            resolve(datas);
        });
    });
}

exports.getASNInfo = async (malware_id) => {
    var malInfo = await getApprovalInfo(malware_id);
    console.log("malInfo:::", malInfo);
    var domain = this.getHostName(malInfo.url_ip);
    var urlStatus = await this.urlStatusCheck(malInfo.url_ip);
    var anonymous = malInfo.anonymous;
    var result = {};
    result.url_ip = malInfo.url_ip;
    result.domain = domain;
    result.status = urlStatus == "online" ? "online" : "offline";
    result.threat = malInfo.threat;
    result.reporter = anonymous ? "anonymous" : result.reporter = malInfo.reporter;
    result.tag = malInfo.tag;
    return result;
}

exports.getASNInfoByCSV = async (csv) => {
    try {
        let domain = this.getHostName(csv.url_ip);
        var ip = await ipLookupPromise(domain);
        var getMalwareInfo = await axios.get('https://api.webcargo.io/whois', {
            params: { key: "LyH47uEcVXvLI9jgQwrTif5qr2a89vSi", identifier: domain }
        });
        // var getMalwareInfo = await getWhoisInfo(domain);
        var getAsnInfo = await axios.get('https://api.iptoasn.com/v1/as/ip/' + ip);
        var getGeoInfo = await axios.get('https://api.webcargo.io/ip', {
            params: { key: "LyH47uEcVXvLI9jgQwrTif5qr2a89vSi", ip_address: ip }
        });
        var urlStatus = await this.urlStatusCheck(malInfo.url_ip);
        var malwareInfo = getWhoisInfo.data.result;
        var result = {};


        result.domain = domain;
        result.ip = ip;
        result.ASN = getAsnInfo.data.as_number;
        result.country = getGeoInfo ? getGeoInfo.data.country_code : "";

        if (malwareInfo) {
            result.domain_registrar = malwareInfo.registrar ? malwareInfo.registrar.name : "";
            result.domain_ip_owner = malwareInfo.contacts.length == 0 ? "" : malwareInfo.contacts.owner[0].organization;
        } else {
            result.domain_registrar = "";
            result.domain_ip_owner = "";
        }
        result.status = urlStatus == "online" ? "online" : "offline";
        result._id = csv._id;
        result.url_ip = csv.url_ip;
        result.threat = csv.threat;
        result.reporter = csv.reporter;
        result.tag = csv.tag;
        return result;
    } catch (e) {
        console.log('error message', e);
    }
}

exports.checkExistDomain = async (domain) => {
    var existDomain = await findDomain(domain);
    if (existDomain) {
        return true;
    } else {
        return false;
    }
}

exports.getHostName = (url) => {
    var match = url.match(/:\/\/(www[0-9]?\.)?(.[^/:]+)/i);
    if (match != null && match.length > 2 && typeof match[2] === 'string' && match[2].length > 0) {
        return match[2];
    }
    else {
        return null;
    }
}